#!/usr/bin/env perl

use strict; 
use warnings;
use Getopt::Long;
use Pod::Usage;
use List::Util; 
eval "require MIDI"
or die 'mtd.pl: requires the MIDI module to work. See <http://www.cpan.org/modules/INSTALL.html>.';

use version; our $VERSION = '0.0.2';


# prepare command-line options and arguments,
# check required options, add some boiler plate options (help, manual, etc)
# redirect input/output/err files to canonical handles,
GetOptions(
    \%ARGV,
    'input|i=s', 'output|o=s', 'err|e=s',
    'resolution|r=i', 'magnitude|m=f',
    'pattern|p=f@{,}', 'named-pattern|np=f%',
    'tolerance|t=f', 'loop|l=i', 'tempo|t=f',
    _meta_options(\%ARGV),
) and ($ARGV{pattern} or $ARGV{'named-pattern'})
or pod2usage(-verbose => 1);

my ( $INH, $OUTH, $ERRH ) = _prepare_io( \%ARGV, \@ARGV );


# read in midi file either from STDIN or file,
# depending on what user has specified.
# we need to check that the file format is v1,
# since I don't really understand all the possible variations.
my $opus = MIDI::Opus->new({
    @ARGV
    ? (from_file   => shift @ARGV)
    : (from_handle => $INH)
});

# die 'smtd: wrong MIDI file format: ',
#     $opus->format,
#     ' (should be format 1 --- synchronous multitracks)'
# unless $opus->format == 1;

# default resolution to fastest metrical level
# default magnitude to 1 ms, this allows to use -p in absolute terms
# default grid tolerance to 0 ms
# allow user to specify either positional or named patterns
# note that named patterns, if present, override positional ones
$ARGV{resolution} ||= $opus->fastest_metrical_level;
$ARGV{magnitude}  ||= 1;
$ARGV{tolerance}  ||= 0;
$ARGV{pattern}      = named_to_positional_pattern($ARGV{'named-pattern'})
                      if $ARGV{'named-pattern'};
$ARGV{loop}       ||= 1;
$ARGV{tempo}      ||= $opus->bpm;

$opus = $opus->to_format_1;
$opus->set_bpm($ARGV{tempo});


# main program:
# The strategy is to make all midi events' delta-times absolute,
# that is, relative to the very first event offset.
my $abs_events = $opus->rel2abs;

# Then, change each event that falls on the grid
# *SORT* the events by their new absolute position
# since some later ones may now have a smaller value than earlier ones
my @abs_events
= sort { $a->[1] <=> $b->[1] }
map {
    $opus->mtd(
        event => $_,
        resolution  => $ARGV{resolution},
        magnitude => $ARGV{magnitude},
        weights => $ARGV{pattern},
        tolerance => $ARGV{tolerance}
    )
} @$abs_events;

# we can now replace the original events by the modified ones,
# after converting them back to relative offsets, knowing that
# there can be no negative offsets, due to the sorting.
my $rel_events = $opus->abs2rel(\@abs_events);
$opus->tracks_r->[1]->events_r(

    # this just concatenates multiple copies of the events
    # for replicating the input measure[s] $ARGV{loop} times
    [ map { @$rel_events } 1 .. $ARGV{loop} ]

);

# and we're done!
# if we print to STDOUT, binary data might screw up the terminal
# run '$ reset' if that happens
$ARGV{output}
? $opus->write_to_file($ARGV{output})
: $opus->write_to_handle($OUTH);





# boiler-plate stuff
sub _meta_options {
    my ($opt) = @_;

    return (
        'quiet'     => sub { $opt->{quiet}   = 1;          $opt->{verbose} = 0 },
        'verbose:i' => sub { $opt->{verbose} = $_[1] // 1; $opt->{quiet}   = 0 },
        'version'   => sub { pod2usage( -sections => ['VERSION', 'REVISION'],
                                        -verbose  => 99 )                      },
        'license'   => sub { pod2usage( -sections => ['AUTHOR', 'COPYRIGHT'],
                                        -verbose  => 99 )                      },
        'usage'     => sub { pod2usage( -sections => ['SYNOPSIS'],
                                        -verbose  => 99 )                      },
        'options'   => sub { pod2usage( -sections => ['OPTIONS'],
                                        -verbose  => 99 )                      },
        'help'      => sub { pod2usage( -verbose  => 1  )                      },
        'manual'    => sub { pod2usage( -verbose  => 2  )                      },
    );
}
sub _prepare_io {
    my ($opt, $argv) = @_;

    my ($INH, $OUTH, $ERRH);
    
    # If user explicitly sets -i, put the argument in @$argv
    unshift @$argv, $opt->{input} if exists $opt->{input};

    # Allow in-situ arguments (equal input and output filenames)
    if (    exists $opt->{input} and exists $opt->{output}
               and $opt->{input} eq $opt->{output} ) {
        open $INH, q{<}, $opt->{input}
            or die "Can't read $opt->{input}: $!";
        unlink $opt->{output};
    }
    else { $INH = *STDIN }

    # Redirect STDOUT to a file if so specified
    if ( exists $opt->{output} and q{-} ne $opt->{output} ) {
        open $OUTH, q{>}, $opt->{output}
            or die "Can't write $opt->{output}: $!";
    }
    else { $OUTH = *STDOUT }

    # Log STDERR if so specified
    if ( exists $opt->{error} and q{-} ne $opt->{error} ) {
        open $ERRH, q{>}, $opt->{error}
            or die "Can't write $opt->{error}: $!";
    }
    elsif ( exists $opt->{quiet} and $opt->{quiet} ) {
        use File::Spec;
        open $ERRH, q{>}, File::Spec->devnull
            or die "Can't write $opt->{error}: $!";
    }
    else { $ERRH = *STDERR }

    return ( $INH, $OUTH, *STDERR = $ERRH );
}

# utilities
sub named_to_positional_pattern {
    my ($named) = @_ or return;

    my @positional = map { $named->{$_} || 0 }
    (1 .. List::Util::max(keys %$named));

    return \@positional;
}
sub group_by {
    my ($n, @list, @group_by) = @_;

    push @group_by, [splice @list, 0, $n]
    while @list;

    return @group_by;
}


# Monkey-patch MIDI::Opus for the syntactic sugar.
# this defines useful conversion functions, predicates, etc.
package MIDI::Opus;
sub beats_per_measure {
    return (
        List::Util::first { $_->[0] eq 'time_signature' } 
        shift->tracks_r->[0]->events
    )->[2];
}
sub fastest_metrical_level {
    return $_[0]->beats_per_measure
    *
    (
        List::Util::first { $_->[0] eq 'time_signature' } 
        $_[0]->tracks_r->[0]->events
    )->[5];
}
sub set_tempo {
    return (
        List::Util::first { $_->[0] eq 'set_tempo' } 
        shift->tracks_r->[0]->events
    )->[2];
}
sub set_bpm {
    my $tempo_event =
    List::Util::first { $_->[0] eq 'set_tempo' } 
    @{$_[0]->tracks_r->[0]->events_r};

    $tempo_event->[2] = $_[0]->bpm_to_set_tempo($_[1]);
    return $tempo_event;
}
sub bpm_to_set_tempo { return sprintf("%.0f", 60_000_000 / $_[1]) }
sub bpm { return 60_000_000 / $_[0]->set_tempo }
sub mu_per_tick { return $_[0]->set_tempo / $_[0]->ticks }
sub ms_per_tick { return $_[0]->mu_per_tick / 1000 }
sub ms_to_ticks { return sprintf("%.0f", $_[1] / $_[0]->ms_per_tick) }
sub mtd {
    my ($self, %o) = @_;

    if (my $weight_index = $self->in_grid($o{event}, $o{resolution}, $o{tolerance})) {

        $o{event}->[1]
        += sprintf(
            "%.0f",
            $self->ms_to_ticks($o{magnitude} * $o{weights}->[$weight_index])
        );
    }

    return $o{event};
}
sub tick_length {
    return List::Util::sum
    map { $_->[1] }
    $_[0]->tracks_r->[1]->events
}
sub note_count { 
    return sprintf(
        "%.0f",
        ($_[0]->tick_length / $_[0]->ticks)
        * ($_[1] / $opus->beats_per_measure)
    )
}
sub get_grid {
    my ($self, $note) = @_;

    return
    main::group_by(
        $note,
        map { $_ * $self->ticks / ($note / $opus->beats_per_measure) }
        0 .. $self->note_count($note)
    );;
}
{
    my $tick = 0;

    sub in_grid {
        my ($self, $event, $note, $tolerance) = @_;

        $tick += $event->[1];
        $tolerance = $self->ms_to_ticks($tolerance);

        for my $measure ($self->get_grid($note)) {
            for my $nth_note (1 .. @$measure) {
                return $nth_note - 1
                if  $tick >= $measure->[$nth_note - 1] - $tolerance
                and $tick <= $measure->[$nth_note - 1] + $tolerance;
            }                
        }
        return;
    }
}
sub scale_grid {
    my ($self, $factor) = @_;

    $self->ticks( $self->ticks * $factor );

    for ( @{$self->tracks_r->[1]->events_r} ) {
        $_->[1] *= $factor;
    }
}
sub shift_grid {
    my ($self) = @_;

    my $events = $self->tracks_r->[1]->events_r;

    for ( 1 .. @$events - 1 ) {

        if ($events->[$_] < 0) {
            $events->[$_ - 1] -= $events->[$_];
            $events->[$_] = 0;
        }
    }
}
sub rel2abs {
    my ($self) = @_;

    my @abs = ($self->tracks_r->[1]->events_r->[0]);

    for (@{$self->tracks_r->[1]->events_r}) {
        my $accumulator = $abs[-1]->[1] + $_->[1];
        push @abs, [$_->[0], $accumulator, @{$_}[2 .. @{$_}-1]];
    }

    return \@abs;
}
sub abs2rel {
    my ($self, $abs) = @_;

    my @rel = ($abs->[0]);

    push @rel, [
        $abs->[$_][0], 
        $abs->[$_][1] - $abs->[$_ - 1][1],
        @{$abs->[$_]}[2 .. @{$abs->[$_]} - 1]
    ]
    for 1 .. @$abs - 1;
    
    return \@rel;
}
sub to_format_1 {
    my ($self) = @_;
    return $self if $self->format == 1;

    my $copy = $self->copy;

    my (@track_1_events, @track_2_events);
    my %event_dispatch = (
        time_signature => \@track_1_events,
        set_tempo      => \@track_1_events,
        note_on        => \@track_2_events,
        note_off       => \@track_2_events,
    );
    
    for my $track (@{$copy->tracks_r}) {
        while (my $event = shift @{$track->events_r}) {
            push (($event_dispatch{$event->[0]} || \@track_1_events), $event);
        }
    }

    $copy->format(1);
    $copy->tracks(
        MIDI::Track->new({events => \@track_1_events}),
        MIDI::Track->new({events => \@track_2_events}),
    );

    return $copy;
}
__END__


=head1 NAME

 smtd - Introduce systematic microtiming deviations into a MIDI file


=head1 SYNOPSIS

 smtd < [-p WEIGHT_i ...] | [-np i=WEIGHT_i ...]>
      [-r RESOLUTION]                   
      [-m MAGNITUDE]                    
      [-i|< [rhythm.mid]]
      [-o|> [mtd-rhythm.mid]]

 # explicit 8th note resolution, 30ms magnitude, positional weight pattern
 smtd -r 8 -m 30 -p 0 0 1 0.5 0 0 1 0.5 -i in.mid -o out.mid

 # explicit 16th note resolution, selected named weight pattern
 smtd -r 16 -m 30 -np 4=1 -np 8=0.5 -i in.mid -o out.mid

 # implicit signature-based resolution, magnitude, STDIN and STDOUT
 smtp --named 1=1 3=30.0 5=15.0 7=30.0 9=15.0 < in.mid > out.mid


=head1 DESCRIPTION

 Takes a format-1 MIDI file via STDIN, positional, or named argument,
 and prints it to STDOUT or a file with certain note_on and note_off
 events offset by a weighted magnitude in milliseconds.
 

=head1 OPTIONS

 -i,  --input      [string]   (STDIN)     input MIDI filename  
 -o,  --output     [string]   (STDOUT)    output MIDI filename
 -e,  --error      [string]   (STDERR)    error log filename
 -r,  --resolution [integer]  (MIDI DIV)  note durations in pattern
                                          (2-hn, 4-qn, ...)
 -m,  --magnitude  [decimal]  (1)         maximum deviation in ms
 -p,  --pattern    [decimal list]         weights/position in measure
                                          size(weights)=resolution))
 -n,  --npattern   [integer=decimal list] position=weight in measure
 -l,  --loop       [integer]              loop MIDI track n times
 -t,  --tempo      [decimal]              override MIDI tempo in BPM
      --verbose    [integer]              verbose error messages
      --quiet                             no warning messages
      --version                           print current version
      --license                           author and copyright
      --help                              print this information
      --usage                             usage only
      --options                           options only
      --manual                            complete manual page


=head1 VERSION

 0.0.2


=head1 AUTHOR

 Pedro Silva <pasilva@inescporto.pt> 
 Sound and Music Computing Group 
 Telecommunications and Multimedia Unit
 INESC Porto


=head1 COPYRIGHT

 Copyright (C) 2011 Pedro Silva

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.

=cut
